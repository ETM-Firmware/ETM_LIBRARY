#ifndef __ETM_EEPROM_NEW_H
#define __ETM_EEPROM_NEW_H

/*
  EEPROM is broken into logical Pages
  Each page is 32 bytes, 16 words
  This is 14 data words and 2 words of checking
       1 word of status (provided by the user) 
       1 word of CRC (generated by this module)
  
  Register locations are 0->(EEPROM_SIZE_WORDS/2)  - We divide by two because each page is mirrored 
  note that all xXXF registers can not be directly written because they are CRC and managed by this module
  
  EEPROM is set up with adjacent pages and primary and mirror pages
  for example 
  logical page 0 uses eeprom page 0 with page 1 as the mirror
  logical page 3 uses eeprom page 6 with page 7 as the mirror

  Register location 32 is logical page 2 word zero
  Therefore it is found at absolute location Page 4 word zero and mirrored at Page 5 word zero
*/


void ETMEEPromUseInternal(void);
/*
  Tells the module to direct all EEPROM read/writes to the internal EEPROM
  If the device does not have an enternal EEPROM, the read commands will all return zero
  
  The ETMEEPromUseInternal, ETMEEPromUseI2C, and ETMEEPromUseSPI can be used to switch between the EEProms within the application
*/

void ETMEEPromUseI2C(void);
/*
  Tells the module to direct all EEPROM read/writes to the external I2C EEPROM
  In order to use the external EEPROM, ETMEEPromConfigureI2CDevice must be called
  If the devide does not have an I2C port or an I2C EEPROM, weird things may happen
  
  The ETMEEPromUseInternal, ETMEEPromUseI2C, and ETMEEPromUseSPI can be used to switch between the EEProms within the application
*/

void ETMEEPromUseSPI(void);
/*
  Tells the module to direct all EEPROM read/writes to the external SPI EEPROM
  In order to use the external EEPROM, ETMEEPromConfigureSPIDevice must be called
  If the devide does not have an SPI port or an SPI EEPROM, weird things may happen
  
  The ETMEEPromUseInternal, ETMEEPromUseI2C, and ETMEEPromUseSPI can be used to switch between the EEProms within the application
*/


unsigned int ETMEEPromReturnActiveEEProm(void);
/*
  Reutrns ETM_EEPROM_INTERNAL_SELECTED if the internal EEPROM is currently selected for read/write operations
  Returns ETM_EEPROM_I2C_SELECTED if the external I2C EEPROM is currently selected for read/write operations
  Returns ETM_EEPROM_SPI_SELECTED if the external SPI EEPROM is currently selected for read/write operations
*/


void ETMEEPromConfigureI2CDevice(unsigned int size_bytes,
				   unsigned long fcy_clk,
				   unsigned long i2c_baud_rate,
				   unsigned char i2c_address,
				   unsigned char i2c_port);
/*
  This configures the EEPROM and initializes the eeprom
  It should only be called if using an external EEPROM
  If the internal EEPROM is used this will do nothing
*/


void ETMEEPromConfigureSPIDevice(unsigned int size_bytes,
				 unsigned long fcy_clk,
				 unsigned long spi_bit_rate,
				 unsigned int  spi_port,
				 unsigned long pin_chip_select_not,
				 unsigned long pin_hold,
				 unsigned long pin_write_protect);
/*
  This configures the EEPROM and initializes the eeprom
  It should only be called if using an external EEPROM
  If the internal EEPROM is used this will do nothing
*/


unsigned int ETMEEPromReadPage(unsigned int page_number, unsigned int *page_data);
/*
  Data will be returned in *page_data
  If the function return is 0xFFFF the data is valid
  If the function return is 0, the data is NOT valid
  If the data in "A" mirror is valid, it will be returned without checking the data in "B" mirror

*/


unsigned int ETMEEPromWritePage(unsigned int page_number, unsigned int *page_data);
/* 
   Write data to "A" and "B" mirror, the data is not confirmed to be written correctly.
   Will return 0xFFFF if there were no write errors
   Will return 0 if there was a write error to one (or both) registers
*/


unsigned int ETMEEPromWritePageFast(unsigned int page_number, unsigned int *page_data);
/*
  Write data to "A" or "B" mirror.  Therefore this is at least twice as fast as the normal page write
  For Pages 0 -> 63 (0x3F), this will alternate between writing to the "A" mirror and "B" mirror
  For Pages >= 64 (0x3F), this will always write to the "A" mirror ("B" mirror will never get written)
  Because the ReadPage functions returns page "A" if its CRC checks out then you could miss more recent results written to "B" mirror
  Therefore this function should only be used to write things where you don't care if the most recent write was missed.
  Things like pulse counter, system on time, warm up timers make sense here.
  Will return 0xFFFF if there were no write errors
  Will return 0 if there was a write error
*/


unsigned int ETMEEPromWritePageWithConfirmation(unsigned int page_number, unsigned int *page_data);
/*
  Writes to the A and B pages and confirms the values after writing
  This could take a long time to execute depending upon the EEProm type and bus speed
  Will return 0xFFFF if the page data is confirmed in both registers
  Will return 0 if there were any errors (write/read/crc/confirmation)
*/


unsigned int ETMEEPromWriteWordWithConfirmation(unsigned int register_location, unsigned int data);
/*
  Updates A and B pages where register_location resides and confirms the values after writing
  This could take a long time to execute depending upon the EEProm type and bus speed
  Will return 0xFFFF if the page data is confirmed in both registers
  Will return 0 if there were any errors (write/read/crc/confirmation)
*/


unsigned int ETMEEPromReturnDebugData(unsigned int debug_data_index);
/*
  Returns a single word of debug data.
  Types of debug data defined below
*/

#define ETM_EEPROM_DEBUG_DATA_READ_INTERNAL_COUNT           0
#define ETM_EEPROM_DEBUG_DATA_READ_INTERNAL_ERROR           1
#define ETM_EEPROM_DEBUG_DATA_WRITE_INTERNAL_COUNT          2
#define ETM_EEPROM_DEBUG_DATA_WRITE_INTERNAL_ERROR          3
#define ETM_EEPROM_DEBUG_DATA_READ_I2C_COUNT                4
#define ETM_EEPROM_DEBUG_DATA_READ_I2C_ERROR                5
#define ETM_EEPROM_DEBUG_DATA_WRITE_I2C_COUNT               6
#define ETM_EEPROM_DEBUG_DATA_WRITE_I2C_ERROR               7
#define ETM_EEPROM_DEBUG_DATA_READ_SPI_COUNT                8
#define ETM_EEPROM_DEBUG_DATA_READ_SPI_ERROR                9
#define ETM_EEPROM_DEBUG_DATA_WRITE_SPI_COUNT               10
#define ETM_EEPROM_DEBUG_DATA_WRITE_SPI_ERROR               11
#define ETM_EEPROM_DEBUG_DATA_CRC_ERROR                     12



#define ETM_EEPROM_INTERNAL_SELECTED  0
#define ETM_EEPROM_I2C_SELECTED       1
#define ETM_EEPROM_SPI_SELECTED       2

// Used with external eeprom
#define EEPROM_I2C_ADDRESS_0                 0b10100000
#define EEPROM_I2C_ADDRESS_1                 0b10100010
#define EEPROM_I2C_ADDRESS_2                 0b10100100
#define EEPROM_I2C_ADDRESS_3                 0b10100110
#define EEPROM_I2C_ADDRESS_4                 0b10101000
#define EEPROM_I2C_ADDRESS_5                 0b10101010
#define EEPROM_I2C_ADDRESS_6                 0b10101100
#define EEPROM_I2C_ADDRESS_7                 0b10101110

#define EEPROM_SIZE_8K_BYTES                 0x2000
#define EEPROM_SIZE_64K_BITS                 0x2000





#endif
